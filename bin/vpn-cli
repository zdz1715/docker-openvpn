#!/bin/bash

set -e

# 加载函数
. /usr/local/bin/func.sh

# 初始化变量
TEMP_CERT_NAME=''
TEMP_CONF_REMOTE=''
TEMP_CONF_ROUTE=()
TEMP_CONF_PUSH=()

TEMP_CERT_NOPASS=''




VPN_F_CERT_SERVER_NAME=''
VPN_F_CONF_PORT=''
VPN_F_CONF_PLUGIN=''
VPN_F_CONF_SERVER=''


VPN_DIR_SERVER="${OPENVPN}/server"
VPN_DIR_CERT="${EASYRSA_PKI}/issued"
VPN_DIR_KEY="${EASYRSA_PKI}/private"

VPN_FILE_STATUS="${OPENVPN}/openvpn-status.log"
VPN_DIR_CDD="${OPENVPN}/cdd"
VPN_FILE_CRL="${EASYRSA_PKI}/crl.pem"
VPN_FILE_CA="${EASYRSA_PKI}/ca.crt"
VPN_FILE_SERVER="${VPN_DIR_SERVER}/openvpn.conf"

step()
{
  echo "# ========================================================= #"
  echo "# $1 "
  echo "# ========================================================= #"
}

vpn_check() {
  [[ ! -d "$EASYRSA_PKI" ]] && ERROR "目录不存在：$EASYRSA_PKI，请执行：\"vpn-cli init\"" >&2 && exit 1
  [[ ! -r "$VPN_FILE_CA" ]] && ERROR "文件不存在：$VPN_FILE_CA，请执行：\"vpn-cli init\"" >&2 && exit 1
  [[ ! -r "$VPN_FILE_SERVER" ]] && ERROR "文件不存在：$VPN_FILE_SERVER，请执行：\"vpn-cli build-server-conf\"" >&2 && exit 1

  return 0
}




load_env() {
  if [[ -r "$OVPN_ENV" ]]; then
    INFO '载入配置'
    # shellcheck source=src/util.sh
    cat "$OVPN_ENV"
  fi
}

save_env() {
  step "保存配置"
  if [ -f "$OVPN_ENV" ]; then
    bak_env=$OVPN_ENV.$(date +%s).bak
    echo "Backing up $OVPN_ENV -> $bak_env"
    mv "$OVPN_ENV" "$bak_env"
  fi
  INFO "配置："
  (set | grep '^VPN_') | while read -r var; do
    if (echo "$var" | grep '^VPN_F'); then
      echo "[[ -z \$${var%%=*} ]] && declare -x $var"  >> "$OVPN_ENV"
    else
      echo "declare -x $var"  >> "$OVPN_ENV"
    fi
  done
  echo "return 0"  >> "$OVPN_ENV"
}



easy_init() {
  step "初始化证书"


  step_exec easyrsa init-pki
  step_exec easyrsa build-ca "$TEMP_CERT_NOPASS"
  step_exec easyrsa gen-dh
  step_exec openvpn --genkey --secret "$EASYRSA_PKI"/ta.key
  step_exec easyrsa gen-crl

}

vpn_check_req() {
  [[ -r "/etc/openvpn/pki/reqs/$1.req" ]] && return 0
}

vpn_check_name() {
  if [[ -z "$TEMP_CERT_NAME" ]]; then
      ERROR "\"vpn-cli $COMMAND\" requires at least 1 argument: -n|--name"
      exit 1
  fi
}

vpn_client_conf() {
  step "生成客户端端配置文件：$TEMP_CERT_NAME"
  if ! vpn_check_req "$TEMP_CERT_NAME"; then
    step_exec easyrsa build-client-full "$TEMP_CERT_NAME" "$TEMP_CERT_NOPASS"
  else
    WARNING "此证书已存在，不会重新创建"
  fi

  # shellcheck source=src/util.sh
  [[ -r "$OVPN_ENV" ]] && . "$OVPN_ENV"


  echo "############################## 客户端（$TEMP_CERT_NAME）配置 #################################"
  echo "client
dev tun
proto udp
remote ${TEMP_CONF_REMOTE} ${VPN_F_CONF_PORT}
resolv-retry infinite
nobind
persist-key
persist-tun
remote-cert-tls server
cipher AES-256-CBC
compress lz4-v2
reneg-sec 0
verb 3
<ca>
$(cat ${VPN_FILE_CA})
</ca>
<tls-auth>
$(cat ${EASYRSA_PKI}/ta.key)
</tls-auth>
key-direction 1
<cert>
$(openssl x509 -in ${VPN_DIR_CERT}/${TEMP_CERT_NAME}.crt)
</cert>
<key>
$(cat ${VPN_DIR_KEY}/${TEMP_CERT_NAME}.key)
</key>
route-nopull
route $(get_route ${VPN_F_CONF_SERVER}) vpn_gateway"

  for c_route in "${TEMP_CONF_ROUTE[@]}"; do
     echo "route ${c_route}"
  done

  echo "#######################################################################################"
}

vpn_init() {
  easy_init
  vpn_server_conf
}

server_conf_init() {

  [[ -n "$TEMP_CERT_NAME" ]] && VPN_F_CERT_SERVER_NAME=$TEMP_CERT_NAME

  # shellcheck source=src/util.sh
  [[ -r "$OVPN_ENV" ]] && . "$OVPN_ENV"

  [[ -z "$VPN_F_CERT_SERVER_NAME" ]] && VPN_F_CERT_SERVER_NAME='vpn_server'
  [[ -z "$VPN_F_CONF_PORT" ]] && VPN_F_CONF_PORT=1194
  [[ -z "$VPN_F_CONF_SERVER" ]] && VPN_F_CONF_SERVER='10.8.0.0/24'

  return 0
}

vpn_server_conf() {

  server_conf_init
  # shellcheck source=src/util.sh
  [[ -r "$OVPN_ENV" ]] && . "$OVPN_ENV"

  step "生成服务端配置文件：$VPN_F_CERT_SERVER_NAME"

  if ! vpn_check_req "$VPN_F_CERT_SERVER_NAME"; then
    step_exec easyrsa build-server-full "$VPN_F_CERT_SERVER_NAME" "$TEMP_CERT_NOPASS"
  else
    WARNING "此证书已存在，不会重新创建"
  fi



  if [[ ! -d "$VPN_DIR_CDD" ]];then
    step_exec mkdir -p "$VPN_DIR_CDD"
  fi

cat > "$VPN_FILE_SERVER" <<EOF
port ${VPN_F_CONF_PORT}
proto udp
dev tun
ca ${VPN_FILE_CA}
cert ${VPN_DIR_CERT}/${VPN_F_CERT_SERVER_NAME}.crt
key ${VPN_DIR_KEY}/${VPN_F_CERT_SERVER_NAME}.key
dh ${EASYRSA_PKI}/dh.pem
server $(get_route $VPN_F_CONF_SERVER)
ifconfig-pool-persist ${OPENVPN}/ipp.txt
client-config-dir ${VPN_DIR_CDD}
# 客户端互相可以访问
client-to-client
# 可以多个终端登录一个账户
;duplicate-cn
# 心跳，每10s ping一次，ping不到60s之后认定客户端宕机
keepalive 10 120
# tls 加密验证，服务端为0，客户端为1
tls-auth ${EASYRSA_PKI}/ta.key 0
cipher AES-256-CBC
# 压缩
compress lz4-v2
# 最大连接客户端
max-clients 1000
# 使用nobody用户运行，更安全
# user nobody
# group nobody
# 禁止openvpn证书自动过期，以便用户保持连接
reneg-sec 0
persist-key
persist-tun
# 状态日志
status ${VPN_FILE_STATUS}
# 日志级别 0-9,等级越高日志内容越详细
verb 3
# 当服务器重新启动时，通知客户端，以便它可以自动重新连接。只支持udp协议
explicit-exit-notify 1
# 注销证书验证
crl-verify ${VPN_FILE_CRL}
EOF

  for c_push in "${TEMP_CONF_PUSH[@]}"; do
     echo "push \"${c_push}\"" >> "$VPN_FILE_SERVER"
  done


  echo "############################## 服务端配置 #############################################"

  cat "$VPN_FILE_SERVER"

  echo "#######################################################################################"

  INFO "下次运行生效"

  save_env
}

vpn_revoke() {
  if ! vpn_check_req "$1" ; then
    ERROR "证书不存在"
    exit 1
  fi

   # shellcheck source=src/util.sh
  [[ -r "$OVPN_ENV" ]] && . "$OVPN_ENV"

  if [[ "$1" == "$VPN_F_CERT_SERVER_NAME" ]]; then
    ERROR "当前服务端证书不能撤销，若想撤销，请先重新生成新的服务端证书"
    exit 1
  fi

  step_exec easyrsa revoke "$1"
  echo "Generating the Certificate Revocation List :"
  step_exec easyrsa gen-crl
}

vpn_renew() {
   if ! vpn_check_req "$1" ; then
    ERROR "证书不存在"
    exit 1
  fi
  step_exec easyrsa renew "$1" "$TEMP_CERT_NOPASS"
}



cert_info() {
    begin=$(openssl x509 -noout -startdate -in "$1" | awk -F= '{ print $2 }')
    end=$(openssl x509 -noout -enddate -in "$1" | awk -F= '{ print $2 }')
    begin=$(date_format "$begin")
    end=$(date_format "$end")
    name=${1%.crt}
    name=${name#"$2"/}
    # check for revocation or expiration
    command="openssl verify -crl_check -CAfile /tmp/cacheck.pem $1"
    result=$($command)
    if [ $(echo "$result" | wc -l) == 1 ] && [ "$(echo "$result" | grep ": OK")" ]; then
        status="VALID "
    else
        result=$(echo "$result" | tail -n 1 | grep error | cut -d" " -f2)
        case $result in
            10)
                status="EXPIRED"
                ;;
            23)
                status="REVOKED"
                ;;
            *)
                status="INVALID"
        esac
    fi

    if [[ "$name" == 'ca' ]]; then
      type='CA    '
    elif [ "$name" != "$3" ]; then
      type='CLIENT'
    else
      type='SERVER'
    fi

    echo "$begin | $end | $status | $type | $name"
    echo "-----------------------------------------------------------------------------------"
}

vpn_list() {
  # shellcheck source=src/util.sh
  [[ -r "$OVPN_ENV" ]] && . "$OVPN_ENV"

  if [ -e "$VPN_FILE_CRL" ]; then
    cat "$VPN_FILE_CA" "$VPN_FILE_CRL" > /tmp/cacheck.pem
  else
    cat "$VPN_FILE_CA" > /tmp/cacheck.pem
  fi
  echo "-----------------------------------------------------------------------------------"
  echo "开始时间            | 结束时间            | 状态   | 类型   | 证书"
  echo "-----------------------------------------------------------------------------------"
  [[ ! -d "$VPN_DIR_CERT" ]] && exit 0

  cert_info "$VPN_FILE_CA" "$EASYRSA_PKI"

  crts=$(find "$VPN_DIR_CERT" -name '*.crt')

  for name in $crts; do
    cert_info "$name" "$VPN_DIR_CERT" "$VPN_F_CERT_SERVER_NAME"
  done
  # Clean
  rm /tmp/cacheck.pem
}

usage() {
    echo
    echo "Usage: vpn-cli COMMAND [OPTIONS]

    Options:
      -h, --help                    帮助
      -n, --name string             证书名称，服务端默认：vpn_server
          --nopass                  证书密码选项
      -P, --plugin string           插件，可选：pam_mysql
      -p, --port int                端口，默认：1194
          --push list               设置服务端push选项
      -r, --remote string           设置客户端remote选项
          --route list              设置客户端route选项
      -s, --server string           内网地址范围，默认：10.8.0.0/24

    Commands:
      build-client-conf             生成客户端配置文件
      build-server-conf             生成服务端配置文件
      check                         检查能否正常运行
      init                          初始化，生成证书和服务端配置文件
      ip                            设置客户端ip
      list                          证书列表
      renew                         证书续期
      revoke                        撤销证书
      status                        客户端连接状态
    "
}





TEMP=$(getopt -o hn:p:P:s:r: --long help,nopass,name:,port:,plugin:,server:,push:,route: -- "$@" 2>/dev/null)
[ $? != 0 ]  && usage && exit 1

eval set -- "${TEMP}"
while :; do
  [ -z "$1" ] && break;
  case "$1" in
    -h|--help)
      usage; exit 0
      ;;
    -n|--name)
      if [[ "$2" == 'ca' ]] || [[ "$2" == 'CA' ]]; then
        ERROR "名称不可用：$2 " >&2 && exit 1
      fi
      TEMP_CERT_NAME=$2; shift 2
      ;;
    -p|--port)
      if [[ ! "$2" =~ ^[0-9]{1,}$  ]] || [[ "$2" -lt 1 ]] || [[ "$2" -gt 65535 ]];then
        ERROR "$1 端口范围：1～65535" >&2 && exit 1
      fi
      VPN_F_CONF_PORT=$2; shift 2
      ;;
    -P|--plugin)
      VPN_F_CONF_PLUGIN=$2; shift 2
      ;;
    -s|--server)
      if [[ ! "$2" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\/[0-9]{1,2}$ ]];then
        ERROR "$1 内网地址范围不合法,格式为：10.8.0.0/24" >&2 && exit 1
      fi

      if [[ ${2#*/} -lt 0 ]] || [[ ${2#*/} -gt 32 ]];then
        ERROR "$1 子网掩码范围为：0～32" >&2 && exit 1
      fi

      VALID_CHECK=$(echo "${2%/*}"|awk -F. '$1<=255&&$2<=255&&$3<=255&&$4<=255{print "yes"}')
      if [[ ${VALID_CHECK:-no} != "yes" ]]; then
            ERROR "$1 ip不合法" >&2 && exit 1
      fi

      VPN_F_CONF_SERVER=$2; shift 2
      ;;
    -r|--remote)
      if [[ ! "$2" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]];then
        ERROR "$1 服务端地址ip不合法" >&2 && exit 1
      fi

      VALID_CHECK=$(echo "${2%/*}"|awk -F. '$1<=255&&$2<=255&&$3<=255&&$4<=255{print "yes"}')
      if [[ ${VALID_CHECK:-no} != "yes" ]]; then
            ERROR "$1 服务端地址ip不合法" >&2 && exit 1
      fi

      TEMP_CONF_REMOTE=$2; shift 2
      ;;
    --push)
      TEMP_CONF_PUSH=("${TEMP_CONF_PUSH[@]}" "$2"); shift 2
      ;;
    --route)
      TEMP_CONF_ROUTE=("${TEMP_CONF_ROUTE[@]}" "$2"); shift 2
      ;;
    --nopass)
      TEMP_CERT_NOPASS='nopass'; shift 1
      ;;
    --)
      break
      ;;
    *)
      echo "${CWARNING}ERROR: unknown argument! ${CEND}" >&2 && usage && exit 1
  esac
done


# 验证命令
shift
COMMAND="$1"

case "$COMMAND" in
  init)
    vpn_init
    ;;
  build-server-conf)
    vpn_check
    vpn_server_conf
    ;;
  build-client-conf)

    if [[ -z "$TEMP_CERT_NAME" ]] || [[ -z "$TEMP_CONF_REMOTE" ]]; then
      ERROR "\"vpn-cli $COMMAND\" requires at least 2 argument: -n|--name, -r|--remote"
      exit 1
    fi

    vpn_client_conf
    ;;
  revoke)
    vpn_check_name
    vpn_revoke "$TEMP_CERT_NAME"
    ;;
  status)
    tail -F "$VPN_FILE_STATUS"
    ;;
  list)
    vpn_check
    vpn_list
    ;;
  check)
    vpn_check
    SUCCESS "it is ok!"
    ;;
  renew)
    vpn_check
    vpn_check_name
    vpn_renew "$TEMP_CERT_NAME"
    ;;
  *)
    usage && exit 1
    ;;
esac
