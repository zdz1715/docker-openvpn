#!/bin/bash
set -eu

# 加载配置
. /usr/local/bin/func.sh


usage() {
    echo
    echo "Usage: $0 [OPTIONS] COMMAND

    Options:
      -h, --help                    帮助
      -n, --name string             证书名称
      -p, --port int                指定端口，默认：1194
      -P, --plugin string           插件，可选：pam_mysql
      -s, --server string           内网地址范围，默认：10.8.0.0/24
      --push string                 多个请用’,‘分割，格式：route 172.16.100.0 0.0.0.0 net_gateway,dhcp-option DNS 8.8.8.8

    Commands:
      init                          初始化，生成证书和服务端配置文件
      build-server-conf             重新生成服务端配置文件
      build-client-conf             生成客户端配置
      revoke-client                 撤销客户端
      status                        客户端连接状态
      client-list                   客户列表
    "
}

OVPN_PORT=1194
OVPN_SERVER=10.8.0.0/24
OVPN_PLUGIN=''
OVPN_SERVER_CERT_NAME='openvpn-server'
OVPN_SERVER_DIR="${OPENVPN:-}/server"
OVPN_CLIENT_DIR="${OPENVPN:-}/client"
OVPN_SERVER_CONF="${OVPN_SERVER_DIR}/openvpn.conf"
OVPN_STATUS_FILE="${OPENVPN:-}/openvpn-status.log"

OVPN_BUILD_CA=0
OVPN_PAM_MYSQL_PATH=''

while getopts ":n:s:p:" opt; do
    case $opt in
        m)
            OVPN_PLUGIN="$OPTARG"
            ;;
        n)
            OVPN_SERVER_CERT_NAME="$OPTARG"
            ;;
        s)
            OVPN_SERVER="$OPTARG"
            ;;
        p)
            OVPN_PORT="$OPTARG"
            ;;
        \?)
            set +x
            echo "Invalid option: -$OPTARG" >&2
            usage
            exit 1
            ;;
    esac
done




if [ "$OVPN_PLUGIN" = "pam_mysql" ]; then
  apt-get -y install libpam-mysql
  OVPN_PAM_MYSQL_PATH=$(find / | grep pam_mysql.so)
fi

# 初始化
easyrsa init-pki

# 创建ca证书
easyrsa build-ca nopass

# 创建 Diffie-Hellman
easyrsa gen-dh

# tls-auth
openvpn --genkey --secret "$EASYRSA_PKI"/ta.key

# 创建服务端证书
easyrsa build-server-full "$OVPN_SERVER_CERT_NAME" nopass

# 吊销证书列表
easyrsa gen-crl


[ ! -d "${OPENVPN:-}/ccd" ] && mkdir -p ${OPENVPN:-}/ccd
[ ! -d "${OPENVPN:-}/server" ] && mkdir -p ${OPENVPN:-}/server



cat > "$OVPN_SERVER_CONF" <<EOF
port ${OVPN_PORT}
proto udp
dev tun
ca ${EASYRSA_PKI}/ca.crt
cert ${EASYRSA_PKI}/issued/${OVPN_SERVER_CERT_NAME}.crt
key ${EASYRSA_PKI}/private/${OVPN_SERVER_CERT_NAME}.key
dh ${EASYRSA_PKI}/dh.pem
server $(get_route $OVPN_SERVER)
ifconfig-pool-persist ${OPENVPN}/ipp.txt
# 固定客户端ip，如：/cdd/user1
# 内容为ifconfig-push 10.9.0.1 10.9.0.2，则固定ip10.9.0.1
client-config-dir ${OPENVPN}/ccd
# 客户端互相可以访问
client-to-client
# 可以多个终端登录一个账户
;duplicate-cn
# 心跳，每10s ping一次，ping不到60s之后认定客户端宕机
keepalive 10 60
# tls 加密验证，服务端为0，客户端为1
tls-auth ${EASYRSA_PKI}/ta.key 0
cipher AES-256-CBC
# 压缩
compress lz4
# 最大连接客户端
max-clients 1000
# 使用nobody用户运行，更安全
# user nobody
# group nobody
# 禁止openvpn证书自动过期，以便用户保持连接
reneg-sec 0
persist-key
persist-tun
# 状态日志
status ${OVPN_STATUS_FILE}
# 日志级别 0-9,等级越高日志内容越详细
verb 3
# 当服务器重新启动时，通知客户端，以便它可以自动重新连接。只支持udp协议
explicit-exit-notify 1
# 注销证书
crl-verify $EASYRSA_PKI/crl.pem
EOF

if [ -n "$OVPN_PAM_MYSQL_PATH" ];then
cat >> "$OVPN_SERVER_CONF" <<EOF
# pam认证插件，后面是/etc/pam.d的文件名
plugin ${OVPN_PAM_MYSQL_PATH} openvpn
# 不验证客户端的证书，但是服务端的证书还是需要的
client-cert-not-required
# 使用客户提供的UserName作为Common Name
username-as-common-name
EOF
fi

# Preserve config
if [ -f "$OVPN_ENV" ]; then
    bak_env=$OVPN_ENV.$(date +%s).bak
    echo "Backing up $OVPN_ENV -> $bak_env"
    mv "$OVPN_ENV" "$bak_env"
fi

# Save the current OVPN_ vars to the ovpn_env.sh file
(set | grep '^OVPN_') | while read -r var; do
  echo "declare -x $var"  >> "$OVPN_ENV"
done
